import os
import glob
import logging


def link_files(id_file, work_dir):
    """
    :param id_list: file with list of OLC IDs to link
    :param work_dir: destination directory to link files
    """
    fastq_path = os.path.join(work_dir, 'fastq_links')
    try:
        os.mkdir(fastq_path)
    except OSError:
        pass

    # Do a check first with retrieve_sample_dict to avoid redundant link-making effort
    existing_samples = get_sample_dictionary(fastq_path)

    # Read file into a list
    with open(id_file) as f1:
        content = f1.readlines()
    content = [x.strip() for x in content]

    # Create new filtered list
    filtered_id_list = []
    for id in content:
        if id not in existing_samples:
            filtered_id_list.append(id)

    # Write filtered list to text file
    filtered_id_file = id_file.replace('.txt', '_filtered.txt')
    with open(filtered_id_file, 'w') as f2:
        for seqid in filtered_id_list:
            f2.write(seqid + '\n')

    # Do file linking based off of filtered file
    logging.info('Preparing FASTQ links at {}'.format(fastq_path))
    cmd = 'python2 /mnt/nas/MiSeq_Backup/file_linker.py {seqidlist} {output_folder}'.format(
        seqidlist=filtered_id_file,
        output_folder=fastq_path)
    os.system(cmd)
    return fastq_path, filtered_id_list


def retrieve_fastqgz(directory):
    """
    :param directory: Path to folder containing output from MiSeq run
    :return: list of all .fastq.gz files in directory
    """
    fastq_file_list = glob.glob(os.path.join(directory, '*.fastq.gz'))
    return fastq_file_list


def retrieve_unique_sampleids(fastq_file_list):
    """
    :param fastq_file_list: List of fastq.gz filepaths generated by retrieve_fastqgz()
    :return: List of valid OLC Sample IDs
    """
    # Iterate through all of the fastq files and grab the sampleID, append to list
    sample_id_list = list()
    for file in fastq_file_list:
        if valid_olc_id(file):
            sample_id = os.path.basename(file)[:13]  # WARNING: This is specific to the OLC naming scheme
            sample_id_list.append(sample_id)

    # Get unique sample IDs
    sample_id_list = list(set(sample_id_list))

    return sample_id_list


def get_readpair(sample_id, fastq_file_list):
    """
    :param sample_id: String of a valid OLC ID
    :param fastq_file_list: List of fastq.gz file paths generated by retrieve_fastqgz()
    :return: the absolute filepaths of R1 and R2 for a given sample ID
    """

    R1, R2 = None, None
    for file in fastq_file_list:
        if sample_id in os.path.basename(file):
            if 'R1' in os.path.basename(file):
                R1 = file
            elif 'R2' in os.path.basename(file):
                R2 = file
    if R1 is not None:
        return [os.path.abspath(R1), os.path.abspath(R2)]
    else:
        pass


def populate_sample_dictionary(sample_id_list, fastq_file_list):
    """
    :param sample_id_list: List of unique Sample IDs generated by retrieve_unique_sampleids()
    :param fastq_file_list: List of fastq.gz file paths generated by retrieve_fastqgz()
    :return: dictionary with each Sample ID as a key and the read pairs as values
    """

    # Find file pairs for each unique sample ID
    sample_dictionary = {}
    for sample_id in sample_id_list:
        read_pair = get_readpair(sample_id, fastq_file_list)
        sample_dictionary[sample_id] = read_pair
    return sample_dictionary


def get_sample_dictionary(directory):
    """
    Chains several functions together to create a sample dictionary with unique/valid sample IDs as keys
    and paths to forward and reverse reads as values
    :param directory: Path to a directory containing .fastq.gz files
    :return: Validated sample dictionary with sample_ID:R1,R2 structure
    """
    fastq_file_list = retrieve_fastqgz(directory)
    sample_id_list = retrieve_unique_sampleids(fastq_file_list)
    sample_dictionary = populate_sample_dictionary(sample_id_list, fastq_file_list)
    return sample_dictionary


def valid_olc_id(filename):
    """
    Validate that a fastq.gz file contains a valid OLC sample ID
    :param filename: Path to file
    :return: boolean of valid status
    """
    sample_id = os.path.basename(filename).split('_')[0]
    id_components = sample_id.split('-')
    valid_status = False
    if id_components[0].isdigit() and id_components[1].isalpha() and id_components[2].isdigit():
        valid_status = True
    else:
        logging.warning('ID for {} is not a valid OLC ID'.format(sample_id))
    return valid_status


def make_executable(path):
    """
    Takes a shell script and makes it executable
    :param path: path to shell script
    """
    mode = os.stat(path).st_mode
    mode |= (mode & 0o444) >> 2
    os.chmod(path, mode)


def prepare_db_update_script(config_file, work_dir, sample_dictionary):
    """
    Create an executable shell script in fastq_links for every file in the dictionary
    :param config_file:
    :param work_dir:
    :param sample_dictionary:
    :returns: path to the executable script (needs to be run within the SnapperDB venv)
    """
    script_path = os.path.join(work_dir, 'db_update_script.sh')
    logging.info('Creating SnapperDB shell script at {}'.format(script_path))
    with open(script_path, 'w+') as file:
        for key, value in sample_dictionary.items():
            file.write('# {}'.format(key))
            file.write('\n')
            snapperdb = 'run_snapperdb.py '
            snappercmd = 'fastq_to_db '
            config = '-c '
            r1 = ' ' + value[0] + ' '
            r2 = value[1]
            cmd = ''.join([snapperdb, snappercmd, config, config_file, r1, r2])
            file.write(cmd)
            file.write('\n\n')
        file.write('# Updating distance matrix and clusters\n')
        file.write('run_snapperdb.py update_distance_matrix -c {}\n'.format(config_file))
        file.write('run_snapperdb.py update_clusters -c {}'.format(config_file))
    # chmod +x
    make_executable(script_path)
    return script_path

